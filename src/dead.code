    foreach_sexp (tag_ptr, file->cdr()->cdr()) {
	const Sexp* tag = *tag_ptr;

	if(tag->is_pair() || tag->key()->index(0) != ':')
	    return bad_project_file(file, "invalid file attribute");

	const char* attribute = *tag->key();

	if(strcmp(attribute, ":real-file") == 0) {
	    saw_real_file = true;
	} else if(strcmp(attribute, ":no-keywords") == 0) {
	    keyword_sub = false;
	} else if(strcmp(attribute, ":directory") == 0) {
	    if(file_type != RealFile)
		return bad_project_file(tag, "multiple file type attributes");

	    file_type = Directory;
	} else if(strcmp(attribute, ":symlink") == 0) {
	    if(file_type != RealFile)
		return bad_project_file(tag, "multiple file type attributes");

	    file_type = SymLink;
	} else if(strncmp(attribute, ":tag", 4) == 0) {
	    /* its okay */
	} else {
	    return bad_project_file(file, "unrecognized attribute");
	}
    }
	prcsoutput << "Merge file:   " << merge_tuple(working, common, selected)
		   << " by rule " << mergedef->rule_no;

	if(conflict) {
	    prcsoutput << ", conflicts created" << prcsendl;

	    static bool edit_conflicts = false;
	    static SystemCommand* edit_cmd = NULL;

	    if (!edit_conflicts) {
		edit_conflicts = true;

		const char* conflict_editor = get_environ_var ("PRCS_CONFLICT_EDITOR");

		if (conflict_editor)
		    edit_cmd = new SystemCommand(conflict_editor, "PATH");
	    }

	    if (edit_cmd) {
		ArgList* args;

		Return_if_fail(args << edit_cmd->new_arg_list());

		args->append(*working->working_path());

		int retval;

		Return_if_fail(retval << edit_cmd->open_stdout());

		if (retval != 0)
		    prcswarning << "warning: Conflict editor exited with status " << retval << dotendl;
	    }
	} else {
	    prcsoutput << prcsendl;
	}




p#if 0
{
    const char* rcsversion, *versionfile, *working_path;

    Return_if_fail(fe->initialize_descriptor(rep_entry, false, false));

    if(working) {
	Return_if_fail(fe->get_file_sys_info());
    } else {
	Return_if_fail(fe->get_repository_info(rep_entry));
    }

    rcsversion = fe->descriptor_version_number();
    versionfile = fe->full_descriptor_name();
    working_path = fe->working_path();

    if (working) {
	if(fe->keyword_sub()) {
	    Return_if_fail( setkeys(working_path,
				    filename,
				    fe,
				    Unsetkeys) );
	} else {
	    /* Can't symlink here, because gdiff's output is written
	     * over it.  Its bad when you start merging files onto
	     * themselves. */
	    Return_if_fail(fs_copy_filename(working_path, filename));
	}
    } else {
	Return_if_fail(VC_checkout_file(filename, rcsversion, versionfile));
    }

    return NoError;
}
#endif


/* Return whether files differ, possible false positive. */
/* @@@ Wait, can't I check checksums here? */
static bool quick_compare(FileEntry* one,
			  FileEntry* two,
			  bool two_is_working)
{
    if (two_is_working && !two->unmodified() ||
	two_is_working && !two->descriptor_name())
	return true;

    return strcmp (one->descriptor_name(), two->descriptor_name()) != 0 ||
	   strcmp (one->descriptor_version_number(),
		   two->descriptor_version_number()) != 0;
}

/* Can skip a file entirely if this: */
#define SKIP_FILE(md) ((!option_long_format) && \
		       ((md->def_action == (MergeAction)0) || \
			((md->def_action == MergeActionNothing) && \
			 (!option_force_resolution))))

static PrVoidError run_merge_1 (FileEntry* selected,
				FileEntry* common,
				FileEntry* working,
				ProjectDescriptor* working_project,
				MergeCo *co)
{
    const MergeDef *mergedef = NULL;

    for (int i = 0; i < ARRAY_LEN(defaults_1); i += 1) {
	if ((defaults_1[i].have_working  || working == NULL) &&
	    (defaults_1[i].have_common   || common == NULL) &&
	    (defaults_1[i].have_selected || selected == NULL)) {
	    mergedef = defaults_1 + i;
	    break;
	}
    }

    ASSERT (mergedef, "it must be");

    if (SKIP_FILE(mergedef))
	return NoError;

    return finish_merge (selected, common, working, working_project, mergedef, co);
}

static PrVoidError run_merge_2 (FileEntry* selected,
				FileEntry* common,
				FileEntry* working,
				ProjectDescriptor* working_project,
				MergeCo* co)
{
    const MergeDef *mergedef = NULL;
    bool cmp;

    Return_if_fail (cmp << compare_two (selected, common, working, co));

    for (int i = 0; i < ARRAY_LEN(defaults_2); i += 1) {
	if ((defaults_2[i].have_working  || working == NULL) &&
	    (defaults_2[i].have_common   || common == NULL) &&
	    (defaults_2[i].have_selected || selected == NULL)) {
	    bool is_cmp = defaults_2[i].ws_cmp ||
		          defaults_2[i].wc_cmp ||
		          defaults_2[i].sc_cmp;

	    if (cmp == is_cmp) {
		mergedef = defaults_2 + i;
		break;
	    }
	}
    }

    ASSERT (mergedef, "it must be");

    return finish_merge (selected, common, working, working_project, mergedef, co);
}

static PrVoidError run_merge_3 (FileEntry* selected,
				FileEntry* common,
				FileEntry* working,
				ProjectDescriptor* working_project,
				MergeCo* co)
{

}

static PrVoidError run_merge (FileEntry* selected,
			      FileEntry* common,
			      FileEntry* working,
			      ProjectDescriptor* working_project)
{
    /* Do some analysis to determine how far we can get without
     * actually checking out the files.  It can be determined
     * statically, but that makes it impossible to do anything with
     * the no-prompt rules. */
    MergeCo co;

    int count = (selected != NULL) + (common != NULL) + (working != NULL);

    switch (count) {
    case 1:
	return run_merge_1 (selected, common, working, working_project, &co);
    case 2:
	return run_merge_2 (selected, common, working, working_project, &co);
    default:
	return run_merge_3 (selected, common, working, working_project, &co);
    }
}

#if 0
static PrVoidError finish_merge(ProjectDescriptor* working_project,
				FileEntry* selected,
				FileEntry* common,
				FileEntry* working,
				MergeDirective *direct)
{
    MergeAction action;

    if(option_report_actions) {
	working_project->merge_notify(working, common, selected, def_action);

	switch(def_action) {
	case MergeActionMerge:
	    prcsoutput << "Merge file:   " << merge_tuple(working, common, selected)
		       << prcsendl;
	    break;
	case MergeActionReplace:
	    prcsoutput << "Replace file: " << merge_tuple(working, common, selected)
		       << prcsendl;
	    break;
	case MergeActionAdd:
	    prcsoutput << "Add file:     " << merge_tuple(working, common, selected)
		       << prcsendl;
	    break;
	case MergeActionNothing:
	    return NoError;
	case MergeActionDelete:
	    prcsoutput << "Delete file:  " << merge_tuple(working, common, selected)
		       << prcsendl;
	    break;
	}

	return NoError;
    } else if(option_force_resolution) {
	action = def_action;
    } else {
	while(true) {
	    static bool bang_flag = false;
	    char c;

	    if(bang_flag) {
		action = def_action;
		break;
	    }

	    Dstring query;

	    query.sprintf("Please select(%svh!?)[%c] ", valid, (char)def_action);

	    re_query_message = query.cast();
	    re_query_len = query.length();

	    re_query();

	    c = get_user_char();

	    if(c == 0) fprintf(stdout, "\n");

	    if(c == 0 || c == 'q') return PrVoidError(UserAbort);

	    if(c == '?')
		print_merge_help();
	    else if(c == 'h')
		prcsoutput << detail << prcsendl;
	    else if(c == 'v')
		Return_if_fail(view_merge_diffs(selected, common, working));
	    else if(c == '\n') {
		action = def_action;
		break;
	    } else if(c == '!') {
		action = def_action;
		bang_flag = true;
		break;
	    } else if(strchr(valid, c) != NULL) {
		action = (MergeAction)c;
		break;
	    }
	}
    }

    re_query_message = NULL;

    switch(action) {
    case MergeActionMerge:
	bool conflict;

	Return_if_fail(conflict << merge_files (working_project, selected, common, working));

	prcsoutput << "Merge file:   " << merge_tuple(working, common, selected);

	if(conflict) {
	    prcsoutput << ", conflicts created" << prcsendl;

	    static bool edit_conflicts = false;
	    static const char* conflict_editor;

	    if (!edit_conflicts) {
		conflict_editor = get_environ_var ("PRCS_CONFLICT_EDITOR");
		edit_conflicts = true;
	    }

	    if (conflict_editor) {
		static SystemCommand* edit_cmd = NULL;

		if (!edit_cmd)
		    edit_cmd = new SystemCommand(conflict_editor, "PATH");

		ArgList* args;

		Return_if_fail(args << edit_cmd->new_arg_list());

		args->append(*working->working_path());

		int retval;

		Return_if_fail(retval << edit_cmd->open_stdout());

		if (retval != 0)
		    prcswarning << "warning: Conflict editor exited with status " << retval << dotendl;
	    }
	} else {
	    prcsoutput << prcsendl;
	}

	break;
    case MergeActionReplace:
	prcsoutput << "Replace file: " << merge_tuple(working, common, selected) << prcsendl;
	Return_if_fail(replace_file(working_project, selected, common, working));
	break;
    case MergeActionAdd:
	prcsoutput << "Add file:     " << merge_tuple(working, common, selected) << prcsendl;
	Return_if_fail(add_file(working_project, selected, common, working));
	break;
    case MergeActionDelete:
	prcsoutput << "Delete file:  " << merge_tuple(working, common, selected) << prcsendl;
	Return_if_fail(delete_file(working_project, selected, common, working));
	break;
    case MergeActionNothing:
	break;
    }

    working_project->merge_notify(working, common, selected, action);
    return NoError;
}
#endif
PrVoidError view_cs_diffs(FileEntry* selected, FileEntry* common,
			  ProjectDescriptor *selected_project, ProjectDescriptor *common_project)
{
    Return_if_fail(diff_pair(common, selected,
			     temp_file_common,
			     temp_file_selected,
			     common_project,
			     selected_project));
    return NoError;
}

PrVoidError view_cw_diffs(FileEntry* working, FileEntry* common,
			  ProjectDescriptor *working_project, ProjectDescriptor *common_project)
{
    Return_if_fail(diff_pair(common, working,
			     temp_file_common,
			     temp_file_working,
			     common_project,
			     working_project));
    return NoError;
}

PrVoidError view_sw_diffs(FileEntry* working, FileEntry* selected,
			  ProjectDescriptor *working_project, ProjectDescriptor *selected_project)
{
    Return_if_fail(diff_pair(selected, working,
			     temp_file_selected,
			     temp_file_working,
			     selected_project,
			     working_project));
    return NoError;
}

void populate_tables(ProjectDescriptor* P, FileTable* T, FileTable* alt)
{
    foreach_fileent(fe_ptr, P) {
	FileEntry *fe = *fe_ptr;
	const char* key;
	const char* alt_key;

	if (option_file_family) {
	    key = fe->descriptor_name();
	    alt_key = fe->working_path();
	} else {
	    key = fe->working_path();
	    alt_key = fe->descriptor_name();
	}

	if (key)
	    T->insert(key, fe);

	if (alt && alt_key)
	    alt->insert(alt_key, fe);
    }

}

FileEntry* lookup_file(FileEntry* fe, FileTable* table)
{
    FileEntry **fe_ret;

    if (option_file_family) {
	if(fe->descriptor_name()) {
	    fe_ret = table->lookup(fe->descriptor_name());

	    if(fe_ret) {
		return *fe_ret;
	    } else {
		return NULL;
	    }
	} else {
	    return NULL;
	}
    } else {
	fe_ret = table->lookup(fe->working_path());

	if(fe_ret) {
	    return *fe_ret;
	} else {
	    return NULL;
	}
    }
}

/* differs in sense of option_file_family */
FileEntry* alt_lookup_file(FileEntry* fe, FileTable* table)
{
    FileEntry **fe_ret;

    if (!option_file_family) {
	if(fe->descriptor_name()) {
	    fe_ret = table->lookup(fe->descriptor_name());

	    if(fe_ret) {
		return *fe_ret;
	    } else {
		return NULL;
	    }
	} else {
	    return NULL;
	}
    } else {
	fe_ret = table->lookup(fe->working_path());

	if(fe_ret) {
	    return *fe_ret;
	} else {
	    return NULL;
	}
    }
}
static PrVoidError merge_common_files(ProjectDescriptor* /* Selected */,
				      ProjectDescriptor* Common,
				      ProjectDescriptor* Working,
				      FileTable* selected_files,
				      FileTable* /* common_files */,
				      FileTable* work_files,
				      FileTable* /* selected_files_alt */,
				      FileTable* /* common_files_alt */,
				      FileTable* work_files_alt)
{
    FileEntry *common_fe, *selected_fe, *working_fe;

    foreach_fileent(fe_ptr, Common) {
	common_fe = *fe_ptr;

	working_fe = lookup_file(common_fe, work_files);
	selected_fe = lookup_file(common_fe, selected_files);

	bool was_merged = Working->has_been_merged(working_fe, common_fe, selected_fe);

	if(was_merged) {
	    bool remerge;
	    Return_if_fail (remerge << remerge_files (working_fe, common_fe, selected_fe));

	    if (!remerge)
		continue;
	}

	if(!was_merged &&
	   !common_fe->on_command_line() &&
	   (working_fe && !working_fe->on_command_line()) &&
	   (selected_fe && !selected_fe->on_command_line())) {

	    Working->merge_notify_incomplete();
	    continue;
	}

	if(working_fe) {

	    if(selected_fe) {
		Return_if_fail(merge_common_descendants(Working, selected_fe,
							common_fe, working_fe));
	    } else {
		Return_if_fail(merge_working_descendant(Working, NULL,
							common_fe, working_fe));
	    }

	} else if(selected_fe) {

	    if (alt_lookup_file (selected_fe, work_files_alt)) {
		Return_if_fail(cant_add(common_fe, selected_fe));

		Working->merge_notify (NULL, common_fe, selected_fe, MergeActionNothing);
	    } else
		Return_if_fail(merge_selected_descendant(Working, selected_fe,
						     common_fe, NULL));
	} else {
	    Return_if_fail(merge_no_descendant(Working, NULL, common_fe, NULL));
	}
    }

    return NoError;
}

static PrVoidError merge_selected_only_files(ProjectDescriptor* Selected,
					     ProjectDescriptor* /* Common */,
					     ProjectDescriptor* Working,
					     FileTable* /* selected_files */,
					     FileTable* common_files,
					     FileTable* work_files,
					     FileTable* /* selected_files_alt */,
					     FileTable* /* common_files_alt */,
					     FileTable* work_files_alt)
{
    FileEntry *selected_fe, *working_fe;

    foreach_fileent(fe_ptr, Selected) {
	selected_fe = *fe_ptr;

	if(lookup_file(selected_fe, common_files))
	    /* if its in common_files, its been handled by merge_common_files */
	    continue;

	working_fe = lookup_file(selected_fe, work_files);

	if (working_fe)
	    /* handled by merge_working_only_files */
	    continue;

	bool was_merged = Working->has_been_merged(NULL, NULL, selected_fe);

	if(was_merged) {
	    bool remerge;
	    Return_if_fail (remerge << remerge_files (NULL, NULL, selected_fe));

	    if (!remerge)
		continue;
	}

	if(!was_merged && !selected_fe->on_command_line()) {

	    Working->merge_notify_incomplete();
	    continue;
	}

	if (alt_lookup_file (selected_fe, work_files_alt)) {
	    Return_if_fail(cant_add(NULL, selected_fe));

	    Working->merge_notify (NULL, NULL, selected_fe, MergeActionNothing);
	} else
	    Return_if_fail(merge_selected_only_file(Working, selected_fe, NULL, NULL));
    }

    return NoError;
}

static PrVoidError merge_working_only_files(ProjectDescriptor* /* Selected */,
					    ProjectDescriptor* /* Common */,
					    ProjectDescriptor* Working,
					    FileTable* selected_files,
					    FileTable* common_files,
					    FileTable* /* work_files */,
					    FileTable* /* selected_files_alt */,
					    FileTable* /* common_files_alt */,
					    FileTable* /* work_files_alt */)
{
    FileEntry *work_fe, *selected_fe;

    foreach_fileent(fe_ptr, Working) {
	work_fe = *fe_ptr;

	if(lookup_file(work_fe, common_files))
	    /* handled by merge_common_files */
	    continue;

	selected_fe = lookup_file(work_fe, selected_files);

	bool was_merged = Working->has_been_merged(work_fe, NULL, selected_fe);

	if(was_merged) {
	    bool remerge;
	    Return_if_fail (remerge << remerge_files (work_fe, NULL, selected_fe));

	    if (!remerge)
		continue;
	}

	if(!was_merged &&
	   !work_fe->on_command_line() &&
	   (selected_fe && !selected_fe->on_command_line())) {

	    Working->merge_notify_incomplete();
	    continue;
	}

	if(!selected_fe) {
	    Return_if_fail(merge_work_only_file(Working, work_fe, NULL, NULL));
	} else {
	    Return_if_fail(merge_no_ancestor(Working, selected_fe, NULL, work_fe));
	}
    }

    return NoError;
}
/*
 * merge_common_descendants(S, C, W) --
 *
 *     file is present in all three versions.  In this case there are
 *     five cases:                              cmp_wc cmp_sc cmp_sw
 *	 1.  all three files are identicle      0      0      0
 *	 2.  all three files are different      1      1      1
 *	 3.  S and C are the same, W differs    1      0      1
 *	 4.  W and C are the same, S differs    0      1      1
 *	 5.  S and W are the same, C differs    1      1      0
 *     the following actions are taken:
 *	 1.  no action
 *	 2.  default merge
 *	 3.  no action
 *	 4.  default replace
 *	 5.  no action
 *
 *     Files present in PC, PS, and PW, equivalent in PC and PW, and
 *     different in PS.	 The default action is `r'.  That is, the
 *     version in PS is assumed to be most up-to-date.
 *     Files present in PC, PS, and PW, and different in all three.
 *     The default action is `m'.  There have been independent
 *     changes in both PW and PS.
 *     Otherwise PRCS does nothing.
 */
static PrVoidError merge_common_descendants(ProjectDescriptor* Merged,
					    FileEntry* selected_fe,
					    FileEntry* common_fe,
					    FileEntry* working_fe)
{
    FileType ct, st, wt;

    ct = common_fe->file_type();
    st = selected_fe->file_type();
    wt = working_fe->file_type();

    if( wt == ct && st == ct && wt == st && ct == RealFile ) {
	bool cmp_wc, cmp_sc, cmp_sw;
	RepEntry* rep_entry = Merged->repository_entry();

	cmp_sw = quick_compare (selected_fe, working_fe, working_fe->present());

	if (!cmp_sw) {
	    DEBUG ("Quick compare succeeded for "
		   << merge_tuple (working_fe, common_fe, selected_fe)
		   << ", selected == working, done");
	    return NoError;
	}

	cmp_sc = quick_compare (selected_fe, common_fe, false);

	if (!cmp_sc) {
	    DEBUG ("Quick compare succeeded for "
		   << merge_tuple (working_fe, common_fe, selected_fe)
		   << ", selected == common, done");
	    return NoError;
	}

	Return_if_fail(checkout_unkey(temp_file_selected, selected_fe, false, rep_entry, Merged));
	Return_if_fail(checkout_unkey(temp_file_common, common_fe, false, rep_entry, Merged));
	Return_if_fail(checkout_unkey(temp_file_working, working_fe, working_fe->present(),
				      rep_entry, Merged));

	Return_if_fail(cmp_sw << cmp_filenames(temp_file_selected, temp_file_working));

	if (!cmp_sw)
	    return NoError;

	Return_if_fail(cmp_sc << cmp_filenames(temp_file_selected, temp_file_common));

	if (!cmp_sc)
	    return NoError;

	cmp_wc = quick_compare (common_fe, working_fe, working_fe->present());

	if (!cmp_wc) {
	    DEBUG ("Quick compare succeeded for "
		   << merge_tuple (working_fe, common_fe, selected_fe)
		   << ", working == common");
	} else /* Possible false positive */
	    Return_if_fail(cmp_wc << cmp_filenames(temp_file_working, temp_file_common));

	if (cmp_wc) {

	    if(!option_force_resolution || option_long_format) {
		prcsoutput << "Common, selected, and working files "
			   << merge_tuple(working_fe, common_fe, selected_fe)
			   << " all differ" << dotendl;
	    }

	    Return_if_fail(merge_finish(MergeActionMerge, "dmnr", all_files_differ,
					Merged, selected_fe, common_fe, working_fe));
	} else {

	    if(!option_force_resolution || option_long_format) {
		prcsoutput << "Selected file "
			   << merge_tuple(working_fe, common_fe, selected_fe)
			   << " has been modified, working file is unmodified" << dotendl;
	    }

	    Return_if_fail(merge_finish(MergeActionReplace, "dmnr", just_selected_differs,
					Merged, selected_fe, common_fe, working_fe));
	}
    }

    return NoError;
}

/*
 * merge_working_descendant --
 *
 *     file is present in working and common version.
 *
 *     Files present in PC and PW, and absent in PS.  The default
 *     action is `d'.  That is, the files are assumed to be obsolete.
 */
static PrVoidError merge_working_descendant(ProjectDescriptor* Merged,
					    FileEntry* /* selected */,
					    FileEntry* common,
					    FileEntry* working)
{
    FileType ct, wt;

    ct = common->file_type();
    wt = working->file_type();

    if( wt == ct && ct == RealFile ) {

	if(!option_force_resolution || option_long_format)
	    prcsoutput << "No file " << merge_tuple(working, common, NULL)
		       << " in selected version, working file assumed obsolete"
		       << dotendl;

	Return_if_fail(merge_finish(MergeActionDelete, "dn", selected_file_absent,
				    Merged, NULL, common, working));
    }

    return NoError;
}

/*
 * merge_selected_descendant --
 *
 *     file is present in selected and common version.	Compare selected
 *     and common version so as to notify the user of whether it changed
 *     but default in both cases to 'n'
 *
 *     Files present in PC and absent in PW.  The default action is
 *     `n'.  That is, the files are assumed to be obsolete,
 *     regardless of their status in PS.
 */
static PrVoidError merge_selected_descendant(ProjectDescriptor* Merged,
					     FileEntry* selected,
					     FileEntry* common,
					     FileEntry* /* working */)
{
    FileType ct, st;
    const char *detail;

    ct = common->file_type();
    st = selected->file_type();

    if( st == ct && ct == RealFile ) {
	bool cmp;
	RepEntry* rep_entry = Merged->repository_entry();

	Return_if_fail(checkout_unkey(temp_file_selected, selected, false, rep_entry, Merged));
	Return_if_fail(checkout_unkey(temp_file_common, common, false, rep_entry, Merged));

	cmp = quick_compare (selected, common, false);

	if (!cmp) {
	    DEBUG ("Quick compare succeeded for "
		   << merge_tuple (NULL, common, selected)
		   << ", selected == common");
	} else /* Possible false positive */
	    Return_if_fail(cmp << cmp_filenames(temp_file_selected, temp_file_common));

	if(cmp) {

	    if(!option_force_resolution || option_long_format)
		prcsoutput << "No file " << merge_tuple(NULL, common, selected)
			<< " in working version, selected file differs from common version"
			<< dotendl;

	    detail = working_absent_sel_changed;

	} else {

	    if(!option_force_resolution || option_long_format)
		prcsoutput << "No file " << merge_tuple(NULL, common, selected)
			<< " in working version, selected file unchanged from common version"
			<< dotendl;

	    detail = working_absent_sel_unchanged;
	}

	Return_if_fail(merge_finish(MergeActionNothing, "na", detail,
				    Merged, selected, common, NULL));
    }

    return NoError;
}

/*
 * merge_selected_only_file --
 *
 *     file is only present in selected version.  Default is to add.
 *
 *     Files absent in PC and PW, and present in PS. The default
 *     action is `a'.
 *
 */
static PrVoidError merge_selected_only_file(ProjectDescriptor* Merged,
					    FileEntry* selected,
					    FileEntry* /* common */,
					    FileEntry* /* working */)
{
    if( selected->file_type() == RealFile ) {
	Return_if_fail(checkout_unkey(temp_file_selected, selected, false,
				      Merged->repository_entry(), Merged));

	if(!option_force_resolution || option_long_format)
	    prcsoutput << "No file " << merge_tuple(NULL, NULL, selected)
		       << " in working version, file not in common version" << dotendl;

	Return_if_fail(merge_finish(MergeActionAdd, "an", selected_only_detail,
				    Merged, selected, NULL, NULL));
    }

    return NoError;
}

/*
 * merge_work_only_file --
 *
 *     file is only present in working version.	 no action
 *     as per 'PRCS takes no action in other cases, and does not prompt
 *     the user.'
 */
static PrVoidError merge_work_only_file(ProjectDescriptor* /* Merged */,
					FileEntry* /* selected */,
					FileEntry* /* common */,
					FileEntry* /* working */)
{
    /* do nothing */
    return NoError;
}

/*
 * merge_no_descendant --
 *
 *     file is present only in common version.	no action
 *     as per 'PRCS takes no action in other cases, and does not prompt
 *     the user.'
 */
static PrVoidError merge_no_descendant(ProjectDescriptor* /* Merged */,
				FileEntry*, FileEntry*, FileEntry*)
{
    /* do nothing */
    return NoError;
}

/*
 * merge_no_ancestor --
 *
 *     file is present in selected and working versions, but not
 *     common version.
 *     Files absent in PC, and different in PW and PS.	The default
 *     action is `m'
 */
static PrVoidError merge_no_ancestor(ProjectDescriptor* Merged,
			      FileEntry* selected,
			      FileEntry* /* common */,
			      FileEntry* working)
{
    FileType st, wt;

    st = selected->file_type();
    wt = working->file_type();

    if( wt == st && wt == RealFile ) {
	bool cmp;
	RepEntry* rep_entry = Merged->repository_entry();

	cmp = quick_compare (selected, working, working->present());

	if (!cmp) {
	    DEBUG ("Quick compare succeeded for "
		   << merge_tuple (working, NULL, selected)
		   << ", selected == working, done");
	    return NoError;
	}

	Return_if_fail(checkout_unkey(temp_file_selected, selected, false, rep_entry, Merged));
	Return_if_fail(fs_zero_file(temp_file_common));
	Return_if_fail(checkout_unkey(temp_file_working, working, working->present(), rep_entry, Merged));

	Return_if_fail(cmp << cmp_filenames(temp_file_working, temp_file_selected));

	if (!cmp) {
	    return NoError;
	} else {

	    if(!option_force_resolution || option_long_format)
		prcsoutput << "Working and selected files " << merge_tuple(working, NULL, selected)
			   << " differ, no ancestor, merge on the empty file" << dotendl;

	    Return_if_fail(merge_finish(MergeActionMerge, "dmnr", no_ancestor_detail,
					Merged, selected, NULL, working));
	}
    }

    return NoError;
}



struct MergeDirective {
    PrVoidError (*handler)();
};

static MergeDirective nc_ns_w_dirs =
{

};


/* This is a cube of handlers that determines what happens depending
 * on which of the three files are present.  indexed by:
 *
 * [common != NULL][selected != NULL][working != NULL]
 *
 * a cube in file-present-space.  The directives contain data saying
 * what to do.  There are (N/2)(N-1) equality relations to be tested,
 * where N is the number of files present, making optimizations for
 * transitivity.
 */
static MergeDirective* directives[2][2][2] =
{
    /* common == NULL */ {
	/* selected == NULL */ {
	    /* working == NULL (can't really happen--at least one exists) */
	    { NULL },
	    /* working != NULL */
	    { nc_ns_w_dirs }           /* 1 possible */
	},
	/* selected != NULL */ {
	    /* working == NULL */
	    { nc_s_nw_dirs },          /* 1 possible */
	    /* working != NULL */
	    { nc_s_w_dirs }            /* 2 possible */
	}
    },
    /* common != NULL */ {
	/* selected == NULL */ {
	    /* working == NULL */
	    { c_ns_nw_dirs },          /* 1 possible */
	    /* working != NULL */
	    { c_ns_w_dirs }            /* 2 possible */
	},
	/* selected != NULL */ {
	    /* working == NULL */
	    { c_s_nw_dirs },           /* 2 possible */
	    /* working != NULL */
	    { c_s_w_dirs }             /* 5 possible */
	}
    }
};
    SortType stype;

    if (strcmp (option_sort_type, "version") == 0)
	stype = VersionSort;
    else /*if (strcmp (option_sort_type, "date") == 0)*/ /*read_command_line checked*/
	stype = DateSort;
    for(int i = 0; i < versions; i += 1) {

        if(project_data_array->index(i) == NULL)
	    /* Its already been printed */
            continue;

        if(matches(major_pat, project_data_array->index(i)->prcs_major())) {

            ProjectVersionData *thismatch = project_data_array->index(i);

            /* Append the empty version for this major */
            if(strcmp(minor_pat, "0") == 0) {
                versions += 1;
                project_data_array->append(create_pseudo_empty_version(thismatch->prcs_major()));
            }

	    for(int j = i; j < versions; j += 1) {

                if(project_data_array->index(j) == NULL)
                    continue;

                if(matches(thismatch->prcs_major(), project_data_array->index(j)->prcs_major())) {
                    if(matches(minor_pat, project_data_array->index(j)->prcs_minor())) {

			if(project_data_array->index(j)->deleted())
			    continue;

			if(first) {
                            first = false;
                        } else if (option_long_format || option_really_long_format) {
                            prcsoutput << prcsendl;
                        }

			if(strcmp(project_data_array->index(j)->prcs_minor(), "@") == 0)
			    project_data_array->index(j, rep_entry->highest_minor_version_data(thismatch->prcs_major()));

                        Return_if_fail(print_info(project_data_array->index(j), rep_entry));

                    } else if(i == j) {
                        /* append the "@" minor version */
                        versions += 1;
                        project_data_array->append(create_pseudo_latest_version(thismatch));
                    }

                    project_data_array->index(j, (ProjectVersionData*)0);
                }
            }
        }
    }
