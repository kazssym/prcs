.\" Automatically generated by Pod::Man version 1.16
.\" Mon Oct 29 00:29:28 2001
.\"
.\" Standard preamble:
.\" ======================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R

.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.bd B 3
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ======================================================================
.\"
.IX Title "PRCS-SYNCH 1"
.TH PRCS-SYNCH 1 "perl v5.6.1" "2001-10-28" "User Contributed Perl Documentation"
.UC
.SH "NAME"
\&\fBsynch\fR \- synchronize \s-1PRCS\s0 projects between repositories
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Synchronize between old and new repositories, both on local disk:
.PP
.Vb 2
\&    synch --proj=myproject --remote-repo=/somewhere/old \e
\&        --local-repo=/somewhere/new
.Ve
Synchronize over ssh:
.PP
.Vb 1
\&    synch --proj=myproj --ssh=alterego@nowhere.net
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
Standard GNU-style options are used.
.Ip "\fB\*(--proj=\fR\fIname\fR (mandatory)" 4
.IX Item "proj=name (mandatory)"
\&\s-1PRCS\s0 project name.
.Ip "\fB\*(--tmpdir=\fR\fIdirectory\fR (optional)" 4
.IX Item "tmpdir=directory (optional)"
Scratch area, should have ample space relative to project. Defaults to \fI/tmp\fR.
.Ip "\fB\*(--debug=\fR\fIlevel\fR (optional)" 4
.IX Item "debug=level (optional)"
Debug level, higher means more. Default 1.
.Ip "\fB\*(--local-repo=\fR\fIdirectory\fR (optional)" 4
.IX Item "local-repo=directory (optional)"
Local repository: this is where updates will be placed. If not specified, the
envvar \fB\s-1PRCS_REPOSITORY\s0\fR is tried, then the \s-1PRCS\s0 internal configuration.
.Ip "\fB\*(--remote-repo=\fR\fIdirectory\fR (sometimes optional)" 4
.IX Item "remote-repo=directory (sometimes optional)"
\&\*(L"Remote\*(R" repository, i.e. where the original versions are to be synched from.
This is mandatory unless \fB\*(--ssh\fR is specified, in which case the same
heuristics are tried as for the local repository. (If you are accustomed to
\&\fB$PRCS_REPOSITORY\fR being set for your personal environment, try
\&\fI~/.ssh/environment\fR on the remote host.)
.Ip "\fB\*(--dir=\fR{ \fBup\fR | \fBdown\fR | \fBboth\fR } (optional)" 4
.IX Item "dir={ up | down | both } (optional)"
Controls direction of synchronization. By default, \fBboth\fR is assumed: you want
to synchronize changes in both directions. \fBup\fR means send changes to remote
from local only; \fBdown\fR means get changes from remote only.
.Ip "\fB\*(--ssh=\fR [ \fIuser\fR\fB@\fR ] \fIhost\fR (optional)" 4
.IX Item "ssh= [ user@ ] host (optional)"
Access the remote repository using ssh (Secure SHell). This must be installed as
\&\fIssh\fR (and of course the remote host must be running the server).
Give it a hostname or user@host syntax. You may do synchronization in
any direction, but if going upstream, you need to have this script installed and
in your default path on the remote machine as well. ssh may prompt you for
passwords or passphrases multiple times; to avoid this annoyance, you should
set up ssh properly so you have an authenticated identity, and use \fIssh-agent\fR
to make the authentication transparent. If in doubt as to whether this is
working, you should be able to do this and have it not prompt at all:
.Sp
.Vb 1
\&    ssh -l user host echo looks good
.Ve
For a quick test, this will probably work:
.Sp
.Vb 1
\&    ssh-agent sh -c 'ssh-add; synch ....'
.Ve
.Ip "\fB\*(--ssh-opts\fR=\fIoption list\fR (optional)" 4
.IX Item "ssh-opts=option list (optional)"
Pass extra options to \fIssh\fR. Normally none should be needed.
.Ip "\fB\*(--remote-tmpdir\fR=\fIdirectory\fR (optional)" 4
.IX Item "remote-tmpdir=directory (optional)"
Like \fB\*(--tmpdir\fR, but on the remote host if using ssh.
.Ip "\fB\*(--help\fR" 4
.IX Item "help"
Display this documentation.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBsynch\fR tries to synchronize two \s-1PRCS\s0 repositories (actually, just a single
project at a time). It requires a \*(L"remote\*(R" repository, which is
assumed to have recent changes, vs. a \*(L"local\*(R" repository which is out of date
(it has not yet seen these new versions). All versions present in both
repositories must match up in all relevant details. \fBsynch\fR will try to
maintain this synchronization. You could subsequently reverse positions and
synchronize local versions into the remote repository, too. If you are doing
this kind of bidirectional stuff, it is \fIyour responsibility\fR to ensure that
you never check in different versions with the same name into the two
repositories; \fBsynch\fR currently may not notice the discrepancy and may fail
unpredictably. So, e.g., use one repository for most stuff, but reserve a
specially-named branch or two on which all local checkins will be made; this
is the simplest way to ensure that you do not accidentally overlap.
.PP
Please use this only on projects already existing in both repositories. If
you need to create one or another from scratch, this is easy enough to do with
\&\f(CW\*(C`prcs package\*(C'\fR and \f(CW\*(C`prcs unpackage\*(C'\fR (not to mention faster, safer, and more
preserving of metainformation).
.SH "PREREQUISITES"
.IX Header "PREREQUISITES"
.Ip "\(bu" 4
A reasonably recent \s-1PRCS\s0.
.Ip "\(bu" 4
Perl 5.004.
.Ip "\(bu" 4
The SysV utility \fItsort\fR in your path (most systems have this somewhere, let me know
if this is a problem; check \fI/usr/ccs/bin/\fR in Solaris?).
.Ip "\(bu" 4
Ssh if you are doing remote synchs, with an ssh server on the remote host.
.Ip "\(bu" 4
A copy of this script on the remote host to do upstream synchs.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
\&\fI\s-1CAVEAT\s0 \s-1USER\s0\fR: Implementation relies on undocumented and possibly unstable
aspects of \s-1PRCS\s0. The heart is the \fBupdate\fR function, which actually does
the synchronization of remote versions into the local repository.
.PP
The basic algorithm is as follows (this may be incomprehensible):
.PP
For each new version to be added, go through each of its parents in
turn. Check out the project files for both the local and remote
varieties of that parent. In each of these pairs, go through each file
by name, collecting its file family; ignore revision number
correspondences for now on the assumption that they will be the same
(they should be). The list of files should match up one-to-one, else
error. For each filename, create a correspondence between the local
and remote internal file families. (This correspondence should be
retained across versions, in fact, as an extra sanity check.)
.PP
Now check out the version''s remote project file. Edit it as
follows. First, swap \fBNew-Foo\fR with \fBFoo\fR (just edit the symbols!); this
will have the effect of creating the correct \fBNew-Foo\fR, while blanking
out the \fBFoo\fR (which has no effect anyway). Second, substitute all file
families with the corresponding local versions. If there is no
corresponding local version, \fIipso facto\fR this is a new file (it did not
appear in any of its parents), so we blank out the internal descriptor
to indicate this. (If it was deleted, then we do not care.) Third,
change the project version to one of the parents, say the first
one.
.PP
Fourth (the nasty part): for each file descriptor: check to see if the
v.n. in the new remote is the same as in one of the old remotes. If
so, then copy in the v.n. from the corresponding old local. If not,
perform \s-1RCS\s0 subtraction and look for that in the old remotes. If
found, use the corresponding old local. If not, signal an error. (\s-1RCS\s0
subtraction: if ending in \fI...\fR.1.\fIn+1\fR, go to \fI...\fR.1.\fIn\fR; if
\&\fI...\fR.\fIn\fR.1; go to \fI...\fR; if just 1.1, then there should have been no
prior version, so check that.)
.PP
Fifth: make a note of the original user & time of checkin.
.PP
Now you can check in. Phew.
.SH "INTERNAL FUNCTIONS"
.IX Header "INTERNAL FUNCTIONS"
Too many weird little functions in here.
.if n .Sh "\f(CW""get_prj($project, $version, $repository)""\fP"
.el .Sh "\f(CWget_prj($project, $version, $repository)\fP"
.IX Subsection "get_prj($project, $version, $repository)"
Returns the text of the project file for a given version. Cached.
.if n .Sh "\f(CW""get_mapping($project, $project_file)""\fP"
.el .Sh "\f(CWget_mapping($project, $project_file)\fP"
.IX Subsection "get_mapping($project, $project_file)"
Given a project name and the text of some version of the project file,
returns a mapping for the file descriptors. The mapping is a hash ref, from
file names (external) to hashrefs of: the total file descriptor string as it
appears (\fBtotal\fR); the file family (\fBff\fR); and the \s-1RCS\s0 version number
(\fBvn\fR). Cached.
.if n .Sh "\f(CW""remap_by_ff($mapping)""\fP"
.el .Sh "\f(CWremap_by_ff($mapping)\fP"
.IX Subsection "remap_by_ff($mapping)"
Take a mapping as from \fBget_mapping\fR and rekey it by file family. Same as
before but now \fBff\fR is replaced by \fBname\fR.
.if n .Sh "\f(CW""check_ff_mapping($project, $version, $remote_repo, $local_repo)""\fP"
.el .Sh "\f(CWcheck_ff_mapping($project, $version, $remote_repo, $local_repo)\fP"
.IX Subsection "check_ff_mapping($project, $version, $remote_repo, $local_repo)"
Looks for the correspondence between file families between the two repositories.
The indicated version only is checked for this call. \f(CW\*(C`%ff_mapping\*(C'\fR will be a
map from project name, to remote family, to local family. If there is ever a
mismatch (between versions) an error will be raised.
.if n .Sh "\f(CW""rcs_decrement($rcs_vers)""\fP"
.el .Sh "\f(CWrcs_decrement($rcs_vers)\fP"
.IX Subsection "rcs_decrement($rcs_vers)"
Find the \s-1RCS\s0 predecessor to this \s-1RCS\s0 number. If it is of the form \fIxxx\fR.\fIn+1\fR,
then we get \fIxxx\fR.\fIn\fR. If of the form \fIxxx\fR.\fIn\fR.1, then we get \fIxxx\fR. If
it is 1.1, then it has no predecessor so \f(CW\*(C`undef\*(C'\fR is returned.
.if n .Sh "\f(CW""find_local_predecessor_vn($rem_vn, $rem_ff, \e@rem_descs, $loc_ff, \e@loc_descs)""\fP"
.el .Sh "\f(CWfind_local_predecessor_vn($rem_vn, $rem_ff, \e@rem_descs, $loc_ff, \e@loc_descs)\fP"
.IX Subsection "find_local_predecessor_vn($rem_vn, $rem_ff, @rem_descs, $loc_ff, @loc_descs)"
Find the local \s-1RCS\s0 version number which presumably corresponds to the ancestor
of the given remote one. Pass in the observed remote version number; and for
both the local and remote repositories, the observed file family (may be
\&\f(CW\*(C`undef\*(C'\fR for local), and lists consisting of \fBtotal\fR/\fBvn\fR/\fBname\fR hashes (as
from \fBremap_by_ff\fR, but for the correct file family only; \f(CW\*(C`undef\*(C'\fR if not
present), one for each \fIparent\fR version, in corresponding order. The presumed
local version number will be searched for and returned; if the file is observed
to be fresh, \f(CW\*(C`undef\*(C'\fR will be returned.
.PP
This function is where all the nasty logic really lives.
.if n .Sh "\f(CW""update($proj, \e@versions, $local_repo, $remote_repo)""\fP"
.el .Sh "\f(CWupdate($proj, \e@versions, $local_repo, $remote_repo)\fP"
.IX Subsection "update($proj, @versions, $local_repo, $remote_repo)"
Update the specified \s-1PRCS\s0 project according to the contents of a master
repository.
Only the specified list of versions will be updated. Each version specifier
should be of the form \f(CW\*(C`[$version, @parents]\*(C'\fR, i.e. a list reference giving
first the version to update from the package file, then its parents (there
may be multiple in the case of a merge). The function will determine which
order to do the updates in.
.PP
Expects \fI/tmp\fR to be available and have sufficient space for scratch space;
also expects \s-1PRCS\s0 to be installed as \fIprcs\fR, and a topological sort as
\&\fItsort\fR.
.if n .Sh "\f(CW""parse_info_short($proj, $fh)""\fP"
.el .Sh "\f(CWparse_info_short($proj, $fh)\fP"
.IX Subsection "parse_info_short($proj, $fh)"
Given an input filehandle, returns a reflist to all versions present in
that \f(CW\*(C`prcs info\*(C'\fR listing. Project name should be specified.
.if n .Sh "\f(CW""parse_info_long($proj, $fh)""\fP"
.el .Sh "\f(CWparse_info_long($proj, $fh)\fP"
.IX Subsection "parse_info_long($proj, $fh)"
Same as \fBparse_info_short\fR, but input assumed to be from \fBprcs info \-l\fR,
and result versions are \fBupdate\fR\-ready lists w/ parent information.
.PP
Currently not that flexible w.r.t. \s-1PRCS\s0 output format: assumes that the
parent versions immediately follow main line, & there is at least one extra
line after that (e.g. Version-Log).
.if n .Sh "\f(CW""update_based_on_versions($proj, $from_repo, \e@from_vers, $to_repo, \e@to_repo)""\fP"
.el .Sh "\f(CWupdate_based_on_versions($proj, $from_repo, \e@from_vers, $to_repo, \e@to_repo)\fP"
.IX Subsection "update_based_on_versions($proj, $from_repo, @from_vers, $to_repo, @to_repo)"
Update from one repository to another based on the versions currently present in
each. \f(CW@from_repo\fR must be long format; \f(CW@to_repo\fR may be either long or short.
.SH "BUGS"
.IX Header "BUGS"
It is impossible to make the newly created versions have the same login and
checkin time as the original. But this information is recorded at the
beginning of the version log.
.PP
Something about package upload seems to be capable of killing Linux \s-1PPP\s0 links
completely! Please let me know if you have problems with a transmission stopping
partway through (no harm should come of it, as the unpackaging should fail noisily).
This may be a network-code bug, or an ssh bug.
.Sh "Deletions"
.IX Subsection "Deletions"
Version deletions will screw things up somewhat; if this causes problems, the
synch will be stopped and you will be asked to rerun it. \fI\s-1NOTE\s0\fR that this only
works if you have deleted a version (due to a mistake) before checking in any
versions with that as its parent; trying to synch from a repository which
contains versions derived from now-deleted versions will cause a failure!
.PP
If you really need to do synching on projects containing internal deletions
(those with nondeleted children), you have two options (both untested). If
you know you want to do the deletion ahead of time, synch up the projects
first, then do matching deletions in each repository. If you have already done
the internal deletions and want to continue with (or begin) synchronization, you
will have to manually synch up those versions with immediate deleted ancestors,
in which case you are on your own (though it would probably not be that
difficult if you read the implementation notes to this script).
.SH "TODO"
.IX Header "TODO"
Should chdir to some directory with no interesting subdirectories. Else some
\&\s-1PRCS\s0 commands will be interpreted as referring to a subdirectory, rather than a
project name, which produces mysterious errors.
.PP
Should check when updating a new version to see if the v.l. already contains an
[Originally checked in by...], and just keep that one instead of adding a new one.
.PP
Upon dying, it should list all of the scratch directories it was using, for
debugging purposes.
.Sh "Efficiency"
.IX Subsection "Efficiency"
In the case of remote synchs, the entire project package is transmitted, which is
surely wasteful when only a small portion of that is actually used; but this keeps
the code much simpler and hopefully stabler than it would otherwise be. Conceivably
it would be possible to remotely check out the required versions into a directory
tree and .tar.gz the whole mess, relying on gzip to notice the redundancy; this
would still not reduce waste in the case of huge projects only a few files of which
are changing each time.
.PP
Ssh is run a number of times within a remote session, at the cost of some connection
overhead.
.PP
Ssh compression and project-file compression is always turned on where it would reduce
bandwidth requirements. This probably causes a little unnecessary overhead when
running over a fast local network.
.Sh "\fB\*(--revision\fP option"
.IX Subsection "revision option"
Should permit you to only synch up certain revisions or branches. This could be
somewhat tricky, though, as it would need to ensure that the R.T.C. of versions
requested fell within those versions plus the versions already existing in the
destination repository: i.e. that there are no \*(L"gaps\*(R".
.Sh "\fB\*(--all-proj\fP option"
.IX Subsection "all-proj option"
Would synch on all projects present in both repositories, and skip some overhead;
substitute for \fB\*(--proj\fR option.
.Sh "Robustness"
.IX Subsection "Robustness"
Examine common versions quickly to ensure critical parts match up. Currently,
it is expected that the user is being careful to keep branches separate. However,
mistakes on this point might cause other sorts of errors, just not likely to be
as apparent what is wrong.
.PP
The script cannot and does not lock the repository \fIbetween\fR checkins. In principle
this would not break anything, providing you don't do anything dumb like delete project
versions while it is running!
.Sh "Testing"
.IX Subsection "Testing"
Needs to be tested in many more & more obscure circumstances than it has. (That said,
I have been using it since late April without problems.)
.SH "AUTHOR"
.IX Header "AUTHOR"
Jesse Glick \fBjglick@sig.bsh.com\fR. Please send comments & bug reports.
.SH "REVISION"
.IX Header "REVISION"
This is alpha-level software, use at your own risk.
.PP
\&\f(CW\*(C`$ProjectHeader: prcs 1.3\-release.1 Sun, 28 Oct 2001 18:18:09 \-0800 jmacd $\*(C'\fR
.PP
Copyright (C) 1998 Strategic Interactive Group, all rights reserved. This software may
be used under the terms of the \s-1GNU\s0 General Public License. There is no warranty of any
kind whatsoever.
